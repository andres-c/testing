"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sh = require("shelljs");
const got = require("got");
const fs = require("mz/fs");
const path_1 = require("path");
const pkgDir = require("pkg-dir");
const REGISTRY_URL = 'https://registry.npmjs.org';
const EXCEPTION_PACKAGES = new Set(['jest']);
exports.formatPackageMessage = (message, packages) => {
    return packages.length
        ? `${message}:\n${packages.map(p => `  * ${p}`).join('\n')}`
        : '';
};
const parseOpts = (yarn) => {
    return {
        command: yarn ? 'yarn add' : 'npm i',
        devFlag: '-D',
        exactFlag: '-E'
    };
};
exports.installWithTool = (modules, { yarn = false, dev = false, exact = false } = {}) => {
    if (!modules.length) {
        return Promise.resolve();
    }
    const { command, devFlag, exactFlag } = parseOpts(yarn);
    return new Promise((res, rej) => sh.exec([command, dev ? devFlag : '', exact ? exactFlag : '', ...modules].join(' '), 
    // yarn works when silent, but npm doesn't
    { async: true, silent: true }, (code, stdout, stderr) => {
        if (code) {
            rej(stderr);
        }
        res(stdout);
    }));
};
// gets the `@types/name` registry info
exports.getTypingInfo = (name) => __awaiter(this, void 0, void 0, function* () {
    // make sure to encode the / in the name
    const url = `${REGISTRY_URL}/@${encodeURIComponent(`types/${name}`)}`;
    try {
        yield got(url);
        return name;
    }
    catch (e) {
        if (e.statusCode === 404) {
            return null;
        }
        else {
            throw e;
        }
    }
});
// returns null for functions that have type info and the module name if they're missing
exports.missingTypes = (m) => __awaiter(this, void 0, void 0, function* () {
    if (EXCEPTION_PACKAGES.has(m)) {
        return m;
    }
    const pkgRoot = yield pkgDir();
    const installDir = path_1.resolve(`${pkgRoot || '.'}/node_modules/${m}`);
    try {
        const pkg = require(`${installDir}/package.json`);
        // if the file exists at root, it doesn't need to be specified in pkg
        let orphanIndex = false;
        try {
            yield fs.access(`${installDir}/index.d.ts`);
            orphanIndex = true;
        }
        catch (_a) { }
        if (pkg.typings || pkg.types || orphanIndex) {
            return null;
        }
        else {
            return m;
        }
    }
    catch (e) {
        console.error('problem reading', m, ':', e);
        return null;
    }
});
