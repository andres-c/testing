#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const _ = require("lodash");
const utils_1 = require("./utils");
const ora = require("ora");
const chalk_1 = require("chalk");
/* TESTING
 * asdfasdfasdfasdf doesn't exist at all
 * heroku-config has no types at all
 * lodash has types in @types
 * commander, striptags has included types (package.json)
 */
const prodDeps = 'dependencies';
const devDeps = 'devDependencies';
// inverted is whether a flag was passed in
// defaultDev is whether or not devDeps are the default if the first arg is false
const whichDeps = (inverted, defaultDev = false) => {
    if (inverted) {
        if (defaultDev) {
            return prodDeps;
        }
        return devDeps;
    }
    else {
        if (defaultDev) {
            return devDeps;
        }
        return prodDeps;
    }
};
exports.default = (modules, { dev = false, prod = false, yarn = false, exact = false } = {}, shouldSpin = false) => __awaiter(this, void 0, void 0, function* () {
    // SPINNER COMMANDS
    const spinner = ora();
    const log = (message, logAlways = false) => {
        if ((logAlways || shouldSpin) && message) {
            console.log(`${message}\n`);
        }
    };
    const waitOn = (message) => {
        if (shouldSpin) {
            spinner.start(message);
        }
    };
    const succeed = () => {
        if (shouldSpin) {
            spinner.succeed();
        }
    };
    const fail = (e) => {
        if (shouldSpin) {
            spinner.fail();
        }
        console.error(e);
        process.exit(e.code);
    };
    // END OF SPINNER
    // MAIN
    if (dev && prod) {
        log(`${chalk_1.default.redBright('WARNING')} using both --dev and --prod will probably not do what you expect`, true);
    }
    // if there's a yarn lockfile, assume they want to use it
    yarn = yarn || fs_1.existsSync('./yarn.lock');
    log(`Running using ${chalk_1.default.cyanBright(yarn ? 'yarn' : 'npm')}`);
    try {
        waitOn(`Installing Packages into ${chalk_1.default.cyanBright(whichDeps(Boolean(dev)))}`);
        yield utils_1.installWithTool(modules, { dev, yarn, exact });
    }
    catch (e) {
        fail(e);
    }
    succeed();
    const needsTypes = (yield Promise.all(modules.map(utils_1.missingTypes))).filter(Boolean);
    waitOn('Checking for @types');
    const typesToFetch = (yield Promise.all(needsTypes.map(utils_1.getTypingInfo))).filter(Boolean);
    succeed();
    try {
        waitOn(`Installing Available Types into ${chalk_1.default.cyanBright(whichDeps(Boolean(prod), true))}`);
        yield utils_1.installWithTool(typesToFetch.map(t => `@types/${t}`), {
            dev: !Boolean(prod),
            yarn,
            exact
        });
    }
    catch (e) {
        fail(e);
    }
    succeed();
    const missing = _.difference(needsTypes, typesToFetch);
    const installed = _.difference(modules, missing);
    log(utils_1.formatPackageMessage(`\nThe following packages were ${chalk_1.default.greenBright.bold('fully installed')}`, installed));
    log(utils_1.formatPackageMessage(`${
    // need a leading newline if this is our first print statement
    installed.length ? '' : '\n'}The following packages were installed, but ${chalk_1.default.yellowBright.bold('lack types')}`, missing));
});
